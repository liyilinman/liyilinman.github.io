<!DOCTYPE html>
<html>

<head><meta name="generator" content="Hexo 3.9.0">
  
  <title>Archive：2019 - Hexo</title>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  

  <link rel="shortcut icon" href="/favicon.ico" type="image/png">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/archives/2019/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdui@0.4.3/dist/css/mdui.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.15.8/styles/atom-one-dark.css">
   
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">
  
  <link rel="stylesheet" href="//at.alicdn.com/t/font_1038733_0xvrvpg9c0r.css">
  <link rel="stylesheet" href="/css/style.css?v=1608868108152">
</head>

<body class="mdui-drawer-body-left">
  
  <div class="nexmoe-bg" style="background-image: url(https://i.loli.net/2019/01/13/5c3aec85a4343.jpg)"></div>
  <div id="nexmoe-header">
      <div class="nexmoe-drawer mdui-drawer" id="drawer">
    <div class="nexmoe-avatar mdui-ripple">
        <a href="/">
            <img src="/images/avatar.png">
        </a>
    </div>
    <div class="nexmoe-count">
        <div><span>Articles</span>6</div>
        <div><span>Tags</span>0</div>
        <div><span>Categories</span>0</div>
    </div>
    <ul class="nexmoe-list mdui-list" mdui-collapse="{accordion: true}">
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/">
            <i class="mdui-list-item-icon nexmoefont icon-home"></i>
            <div class="mdui-list-item-content">
                回到首页
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/about.html">
            <i class="mdui-list-item-icon nexmoefont icon-info-circle"></i>
            <div class="mdui-list-item-content">
                关于博客
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/PY.html">
            <i class="mdui-list-item-icon nexmoefont icon-unorderedlist"></i>
            <div class="mdui-list-item-content">
                我的朋友
            </div>
        </a>
        
    </ul>
    <aside id="nexmoe-sidebar">
  
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">Social</h3>
    <div class="nexmoe-widget nexmoe-social">
        <a class="mdui-ripple" href="https://space.bilibili.com/20238211" target="_blank" mdui-tooltip="{content: '哔哩哔哩'}" style="color: rgb(231, 106, 141);background-color: rgba(231, 106, 141, .15);">
            <i class="nexmoefont icon-bilibili"></i>
        </a><a class="mdui-ripple" href="https://github.com/nexmoe/" target="_blank" mdui-tooltip="{content: 'GitHub'}" style="color: rgb(25, 23, 23);background-color: rgba(25, 23, 23, .15);">
            <i class="nexmoefont icon-github"></i>
        </a>
    </div>
</div>
  
  

  
  
  
  
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">Archive</h3>
    <div class="nexmoe-widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li></ul>
    </div>
  </div>


  
</aside>
    <div class="nexmoe-copyright">
        &copy; 2020 John Doe
        Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
        & <a href="https://nexmoe.com/hexo-theme-nexmoe.html" target="_blank">Nexmoe</a>
    </div>
</div><!-- .nexmoe-drawer -->

<script>
    const getRealPath = (pathname, desc = false) => {
        if (!pathname) {
            pathname = window.location.pathname
        }
        let names = pathname.split("/")
        if (desc === false) {
            for (let i = names.length - 1; i >= 0; --i) {
                let name = names[i].trim()
                if (name.length > 0 && name !== "/" && name !== "index.html") {
                    return name
                }
            }
        } else {
            for (let i = 0; i < names.length; ++i) {
                let name = names[i].trim()
                if (name.length > 0 && name !== "/" && name !== "index.html") {
                    return name
                }
            }
        }
        return "/"
    }
    let links = document.querySelectorAll('.nexmoe-list-item');
    let rootRealPath = getRealPath(window.location.pathname, true);
    for (let link of links) {
        let linkPath = link.getAttribute("href");
        if (linkPath && getRealPath(linkPath, true) === rootRealPath) {
            link.className = "active nexmoe-list-item mdui-list-item mdui-ripple";
        }
    }
</script>
  </div>
  <div id="nexmoe-content">
    <div class="nexmoe-primary">
        <div class="nexmoe-tab">
            <a mdui-drawer="{target: '#drawer', swipe: true}">
              <i class="mdui-icon material-icons">menu</i>
            </a>
          </div>
        <section class="nexmoe-posts" id="brand-waterfall">
    
    <div class="nexmoe-post">
        <a href="/2019/08/13/基础知识杂记/">
            <div class="nexmoe-post-cover mdui-ripple"> 
                
                    <img src="https://i.loli.net/2019/01/13/5c3aec85a4343.jpg">
                
                <h1>基础知识杂记</h1>
            </div>
        </a>
        <div class="nexmoe-post-meta">
            <a><i class="nexmoefont icon-calendar-fill"></i>2019年08月13日</a>
            <a><i class="nexmoefont icon-areachart"></i>627 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 2 分钟</a>
            
            
        </div>
        <article>
            
            <h4 id="try-catch-finally-执行顺序"><a href="#try-catch-finally-执行顺序" class="headerlink" title="try catch finally 执行顺序 :|"></a>try catch finally 执行顺序 :|</h4><p>1.try 或 catch 中都有 return语句，并且有 finally 的话，最终先执行 finally，再执行 try 或 catch中的 return语句<br>2.try 或 catch 中都有 return语句，并且有 finally，而且 finally中 有return语句 的话，最终先执行 finally，然后执行 finally中 有return语句，并不会执行 try 或 catch 中return语句<br>3.try 或 catch 中都有 return语句，并且有 finally，而且 finally中 对try 或 catch 中的 return语句所返回的基本类型变量/引用类型变量 进行了重新赋值，即使如此，也只会返回 try 或 catch 中的return语句所返回的基本类型变量/引用类型变量的值，finally中的修改try 或 catch 中的返回值操作并不会生效</p>
<h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域 :|"></a>作用域 :|</h4><p>|作用域  | 当前类 | 同一包  |子孙类  |其他包|<br>| — | — | — | — | — | — |<br>|public |      √|       √ |     √ |      √|<br>|protected |   √ |      √|      √|<br>|defalult|     √|       √|<br>|private |     √|</p>
<h4 id="Sleep-和-Wait-方法的区别"><a href="#Sleep-和-Wait-方法的区别" class="headerlink" title="Sleep 和 Wait 方法的区别 :|"></a>Sleep 和 Wait 方法的区别 :|</h4><p>1：所在类不同.<br>   Sleep 属于Thread类中的方法.<br>   Wait  属于Object类中的方法.<br> 2: 使用位置不同.<br>   Sleep 可以在所类中使用.<br>   Wait  只能在同步代码块或者同步方法中使用.<br> 3: 释放锁的方式不同.<br>   Sleep 当调用时,不会立马释放掉锁,而是在执行的执行时间到时,才会释放锁,进入可运行状态.(占用资源)<br>   Wait  当调用时,会立马释放掉锁,进入等待状态,等待其他线程notify唤醒.（不占用资源）</p>
<h4 id="数据库的悲观锁和乐观锁"><a href="#数据库的悲观锁和乐观锁" class="headerlink" title="数据库的悲观锁和乐观锁"></a>数据库的悲观锁和乐观锁</h4><ul>
<li>悲观锁<br>它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。</li>
<li>乐观锁<br>乐观锁机制采取了更加宽松的加锁机制。悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。但随之而来的就是数据库 性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。相对悲观锁而言，乐观锁更倾向于开发运用。</li>
</ul>

            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2019/08/12/数据库索引/">
            <div class="nexmoe-post-cover mdui-ripple"> 
                
                    <img src="https://i.loli.net/2019/01/13/5c3aec85a4343.jpg">
                
                <h1>数据库索引学习笔记</h1>
            </div>
        </a>
        <div class="nexmoe-post-meta">
            <a><i class="nexmoefont icon-calendar-fill"></i>2019年08月12日</a>
            <a><i class="nexmoefont icon-areachart"></i>4k 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 17 分钟</a>
            
            
        </div>
        <article>
            
            <h4 id="HashMap概述："><a href="#HashMap概述：" class="headerlink" title="HashMap概述："></a>HashMap概述：</h4><p> HashMap是基于哈希表的Map接口的非同步实现（Hashtable跟HashMap很像，唯一的区别是Hashtalbe中的方法是线程安全的，也就是同步的）。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p>
<h4 id="HashMap的数据结构："><a href="#HashMap的数据结构：" class="headerlink" title="HashMap的数据结构："></a>HashMap的数据结构：</h4><p> 在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表的数组”的数据结构，每个元素存放链表头结点的数组，即数组和链表的结合体。</p>
<p> HashMap底层就是一个数组，数组中的每一项又是一个链表。当新建一个HashMap的时候，就会初始化一个数组。源码如下：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">transient Entry[] table;</span><br><span class="line"> </span><br><span class="line">static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    final K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line">    final int hash;</span><br><span class="line">    ……</span><br></pre></td></tr></table></figure></p>
<p> 可以看出，Entry就是数组中的元素，每个Map.Entry就是一个key-value对，它持有一个指向下一个元素的引用，这就构成了链表。</p>
<h4 id="HashMap的存取实现："><a href="#HashMap的存取实现：" class="headerlink" title="HashMap的存取实现："></a>HashMap的存取实现：</h4><ul>
<li>存储：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> public V put(K key, V value) &#123;</span><br><span class="line">    // HashMap允许存放null键和null值。</span><br><span class="line">    // 当key为null时，调用putForNullKey方法，将value放置在数组第一个位置。</span><br><span class="line">    if (key == null)</span><br><span class="line">        return putForNullKey(value);</span><br><span class="line">    // 根据key的hashCode重新计算hash值。</span><br><span class="line">    int hash = hash(key.hashCode());</span><br><span class="line">    // 搜索指定hash值所对应table中的索引。</span><br><span class="line">    int i = indexFor(hash, table.length);</span><br><span class="line">    // 如果 i 索引处的 Entry 不为 null，通过循环不断遍历 e 元素的下一个元素。</span><br><span class="line">    for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(this);</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果i索引处的Entry为null，表明此处还没有Entry。</span><br><span class="line">    // modCount记录HashMap中修改结构的次数</span><br><span class="line">    modCount++;</span><br><span class="line">    // 将key、value添加到i索引处。</span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>从上面的源代码中可以看出：当我们往HashMap中put元素的时候，先根据key的hashCode重新计算hash值，根据hash值得到这个元素在数组中的位置（即下标），如果数组该位置上已经存放有其他元素了，那么在这个位置上的元素将以链表的形式存放，新加入的放在链头，最先加入的放在链尾。如果数组该位置上没有元素，就直接将该元素放到此数组中的该位置上。</p>
<p>addEntry(hash, key, value, i)方法根据计算出的hash值，将key-value对放在数组table的 i 索引处。addEntry 是HashMap 提供的一个包访问权限的方法（就是没有public，protected，private这三个访问权限修饰词修饰，为默认的访问权限，用default表示，但在代码中没有这个default），代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void addEntry(int hash, K key, V value, int bucketIndex) &#123;</span><br><span class="line">    // 获取指定 bucketIndex 索引处的 Entry </span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    // 将新创建的 Entry 放入 bucketIndex 索引处，并让新的 Entry 指向原来的 Entry</span><br><span class="line">    table[bucketIndex] = new Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">    // 如果 Map 中的 key-value 对的数量超过了极限</span><br><span class="line">    if (size++ &gt;= threshold)</span><br><span class="line">    // 把 table 对象的长度扩充到原来的2倍。</span><br><span class="line">        resize(2 * table.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当系统决定存储HashMap中的key-value对时，完全没有考虑Entry中的value，仅仅只是根据key来计算并决定每个Entry的存储位置。我们完全可以把 Map 集合中的 value 当成 key 的附属，当系统决定了 key 的存储位置之后，value 随之保存在那里即可。<br>hash(int h)方法根据key的hashCode重新计算一次散列。此算法加入了高位计算，防止低位不变，高位变化时，造成的hash冲突。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">static int hash(int h) &#123;</span><br><span class="line">    h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);</span><br><span class="line">    return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到在HashMap中要找到某个元素，需要根据key的hash值来求得对应数组中的位置。如何计算这个位置就是hash算法。前面说过HashMap的数据结构是数组和链表的结合，所以我们当然希望这个HashMap里面的 元素位置尽量的分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，而不用再去遍历链表，这样就大大优化了查询的效率。</p>
<p>　　对于任意给定的对象，只要它的 hashCode() 返回值相同，那么程序调用 hash(int h) 方法所计算得到的 hash 码值总是相同的。我们首先想到的就是把hash值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，“模”运算的消耗还是比较大的，在HashMap中是这样做的：调用 indexFor(int h, int length) 方法来计算该对象应该保存在 table 数组的哪个索引处。indexFor(int h, int length) 方法的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">static int indexFor(int h, int length) &#123;</span><br><span class="line">    return h &amp; (length-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法非常巧妙，它通过 h &amp; (table.length -1) 来得到该对象的保存位，而HashMap底层数组的长度总是 2 的n 次方，这是HashMap在速度上的优化。在 HashMap 构造器中有如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int capacity = 1;</span><br><span class="line">    while (capacity &lt; initialCapacity)</span><br><span class="line">        capacity &lt;&lt;= 1;</span><br></pre></td></tr></table></figure>

<p>这段代码保证初始化时HashMap的容量总是2的n次方，即底层数组的长度总是为2的n次方。<br>当length总是 2 的n次方时，h&amp; (length-1)运算等价于对length取模，也就是h%length，但是&amp;比%具有更高的效率。<br>这看上去很简单，其实比较有玄机的，我们举个例子来说明：</p>
<p>　　假设数组长度分别为15和16，优化后的hash码分别为8和9，那么&amp;运算后的结果如下：</p>
<pre><code> h &amp; (table.length-1)                     hash                             table.length-1

 8 &amp; (15-1)：                                 0100                   &amp;              1110                   =                0100

 9 &amp; (15-1)：                                 0101                   &amp;              1110                   =                0100

-----------------------------------------------------------------------------------------------------------------------

 8 &amp; (16-1)：                                 0100                   &amp;              1111                   =                0100

 9 &amp; (16-1)：                                 0101                   &amp;              1111                   =                0101

-----------------------------------------------------------------------------------------------------------------------</code></pre><p>　　从上面的例子中可以看出：当8、9两个数和(15-1)2=(1110)进行“与运算&amp;”的时候，产生了相同的结果，都为0100，也就是说它们会定位到数组中的同一个位置上去，这就产生了碰撞，8和9会被放到数组中的同一个位置上形成链表，那么查询的时候就需要遍历这个链 表，得到8或者9，这样就降低了查询的效率。同时，我们也可以发现，当数组长度为15的时候，hash值会与(15-1)2=(1110)进行“与运算&amp;”，那么最后一位永远是0，而0001，0011，0101，1001，1011，0111，1101这几个位置永远都不能存放元素了，空间浪费相当大，更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率，减慢了查询的效率！</p>
<p>　　而当数组长度为16时，即为2的n次方时，2n-1得到的二进制数的每个位上的值都为1（比如(24-1)2=1111），这使得在低位上&amp;时，得到的和原hash的低位相同，加之hash(int h)方法对key的hashCode的进一步优化，加入了高位计算，就使得只有相同的hash值的两个值才会被放到数组中的同一个位置上形成链表。</p>
<p>　　所以说，当数组长度为2的n次幂的时候，不同的key算得得index相同的几率较小，那么数据在数组上分布就比较均匀，也就是说碰撞的几率小，相对的，查询的时候就不用遍历某个位置上的链表，这样查询效率也就较高了。</p>
<p>　　根据上面 put 方法的源代码可以看出，当程序试图将一个key-value对放入HashMap中时，程序首先根据该 key的 hashCode() 返回值决定该 Entry 的存储位置：如果两个 Entry 的 key 的 hashCode() 返回值相同，那它们的存储位置相同。如果这两个 Entry 的 key 通过 equals 比较返回 true，新添加 Entry 的 value 将覆盖集合中原有Entry 的 value，但key不会覆盖。如果这两个 Entry 的 key 通过 equals 比较返回 false，新添加的 Entry 将与集合中原有 Entry 形成 Entry 链，而且新添加的 Entry 位于 Entry 链的头部——具体说明继续看 addEntry() 方法的说明。</p>
<ul>
<li>读取：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">    if (key == null)</span><br><span class="line">        return getForNullKey();</span><br><span class="line">    int hash = hash(key.hashCode());</span><br><span class="line">    for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">        e != null;</span><br><span class="line">        e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))</span><br><span class="line">            return e.value;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>有了上面存储时的hash算法作为基础，理解起来这段代码就很容易了。从上面的源代码中可以看出：从HashMap中get元素时，首先计算key的hashCode，找到数组中对应位置的某一元素，然后通过key的equals方法在对应位置的链表中找到需要的元素。</p>
<ul>
<li><p>归纳起来简单地说，HashMap 在底层将 key-value 当成一个整体进行处理，这个整体就是一个 Entry 对象。HashMap 底层采用一个 Entry[] 数组来保存所有的 key-value 对，当需要存储一个 Entry 对象时，会根据hash算法来决定其在数组中的存储位置，在根据equals方法决定其在该数组位置上的链表中的存储位置；当需要取出一个Entry时，也会根据hash算法找到其在数组中的存储位置，再根据equals方法从该位置上的链表中取出该Entry。</p>
</li>
<li><p>HashMap的resize（rehash）<br>　　当HashMap中的元素越来越多的时候，hash冲突的几率也就越来越高，因为数组的长度是固定的。所以为了提高查询的效率，就要对HashMap的数组进行扩容，数组扩容这个操作也会出现在ArrayList中，这是一个常用的操作，而在HashMap数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize。<br>　　那么HashMap什么时候进行扩容呢？当HashMap中的元素个数超过数组大小<em>loadFactor时，就会进行数组扩容，loadFactor的默认值为0.75，这是一个折中的取值。也就是说，默认情况下，数组大小为16，那么当HashMap中元素个数超过16</em>0.75=12（这个值就是代码中的threshold值，也叫做临界值）的时候，就把数组的大小扩展为 2*16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知HashMap中元素的个数，那么预设元素的个数能够有效的提高HashMap的性能。<br>HashMap扩容的代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//HashMap数组扩容</span><br><span class="line">          void resize(int newCapacity) &#123;</span><br><span class="line">                Entry[] oldTable = table;</span><br><span class="line">                int oldCapacity = oldTable.length;</span><br><span class="line">                //如果当前的数组长度已经达到最大值，则不在进行调整</span><br><span class="line">                if (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                    threshold = Integer.MAX_VALUE;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                //根据传入参数的长度定义新的数组</span><br><span class="line">                Entry[] newTable = new Entry[newCapacity];</span><br><span class="line">                //按照新的规则，将旧数组中的元素转移到新数组中</span><br><span class="line">                transfer(newTable);</span><br><span class="line">                table = newTable;</span><br><span class="line">                //更新临界值</span><br><span class="line">                threshold = (int)(newCapacity * loadFactor);</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">          //旧数组中元素往新数组中迁移</span><br><span class="line">            void transfer(Entry[] newTable) &#123;</span><br><span class="line">                //旧数组</span><br><span class="line">                Entry[] src = table;</span><br><span class="line">                //新数组长度</span><br><span class="line">                int newCapacity = newTable.length;</span><br><span class="line">                //遍历旧数组</span><br><span class="line">                for (int j = 0; j &lt; src.length; j++) &#123;</span><br><span class="line">                    Entry&lt;K,V&gt; e = src[j];</span><br><span class="line">                    if (e != null) &#123;</span><br><span class="line">                        src[j] = null;</span><br><span class="line">                        do &#123;</span><br><span class="line">                            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                            int i = indexFor(e.hash, newCapacity);</span><br><span class="line">                            e.next = newTable[i];</span><br><span class="line">                            newTable[i] = e;</span><br><span class="line">                            e = next;</span><br><span class="line">                        &#125; while (e != null);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>HashMap的性能参数：<br>HashMap 包含如下几个构造器：</p>
</li>
</ul>
<p>1.HashMap()：构建一个初始容量为 16，负载因子为 0.75 的 HashMap。<br>2.HashMap(int initialCapacity)：构建一个初始容量为 initialCapacity，负载因子为 0.75 的 HashMap。<br>3.HashMap(int initialCapacity, float loadFactor)：以指定初始容量、指定的负载因子创建一个 HashMap。<br>4.HashMap的基础构造器HashMap(int initialCapacity, float loadFactor)带有两个参数，它们是初始容量initialCapacity和加载因子loadFactor。<br>5.initialCapacity：HashMap的最大容量，即为底层数组的长度。<br>6.loadFactor：负载因子loadFactor定义为：散列表的实际元素数目(n)/ 散列表的容量(m)。<br>　　负载因子衡量的是一个散列表的空间的使用程度，负载因子越大表示散列表的装填程度越高，反之愈小。对于使用链表法的散列表来说，查找一个元素的平均时间是O(1+a)，因此如果负载因子越大，对空间的利用更充分，然而后果是查找效率的降低；如果负载因子太小，那么散列表的数据将过于稀疏，对空间造成严重浪费。<br>　　HashMap的实现中，通过threshold字段来判断HashMap的最大容量：<br><code>threshold = (int)(capacity * loadFactor);</code><br>结合负载因子的定义公式可知，threshold就是在此loadFactor和capacity对应下允许的最大元素数目，超过这个数目就重新resize，以降低实际的负载因子（也就是说虽然数组长度是capacity，但其扩容的临界值确是threshold）。默认的的负载因子0.75是对空间和时间效率的一个平衡选择。当容量超出此最大容量时， resize后的HashMap容量是容量的两倍：<br><code>if (size++ &gt;= threshold)   
    resize(2 * table.length);</code></p>
<ul>
<li>Fail-Fast机制：<br>　　我们知道java.util.HashMap不是线程安全的，因此如果在使用迭代器的过程中有其他线程修改了map，那么将抛出ConcurrentModificationException，这就是所谓fail-fast策略。（这个在core java这本书中也有提到。）</li>
</ul>
<p>　　这一策略在源码中的实现是通过modCount域，modCount顾名思义就是修改次数，对HashMap内容的修改都将增加这个值，那么在迭代器初始化过程中会将这个值赋给迭代器的expectedModCount。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HashIterator() &#123;</span><br><span class="line">    expectedModCount = modCount;</span><br><span class="line">    if (size &gt; 0) &#123; // advance to first entry</span><br><span class="line">    Entry[] t = table;</span><br><span class="line">    while (index &lt; t.length &amp;&amp; (next = t[index++]) == null)</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在迭代过程中，判断modCount跟expectedModCount是否相等，如果不相等就表示已经有其他线程修改了Map：</p>
<p>　　注意到modCount声明为volatile，保证线程之间修改的可见性。（volatile之所以线程安全是因为被volatile修饰的变量不保存缓存，直接在内存中修改，因此能够保证线程之间修改的可见性）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">final Entry&lt;K,V&gt; nextEntry() &#123;   </span><br><span class="line">    if (modCount != expectedModCount)   </span><br><span class="line">        throw new ConcurrentModificationException();</span><br></pre></td></tr></table></figure>

<p>在HashMap的API中指出：</p>
<p>　　由所有HashMap类的“collection 视图方法”所返回的迭代器都是快速失败的：在迭代器创建之后，如果从结构上对映射进行修改，除非通过迭代器本身的 remove 方法，其他任何时间任何方式的修改，迭代器都将抛出ConcurrentModificationException。因此，面对并发的修改，迭代器很快就会完全失败，而不保证在将来不确定的时间发生任意不确定行为的风险。</p>
<p>　　注意，迭代器的快速失败行为不能得到保证，一般来说，存在非同步的并发修改时，不可能作出任何坚决的保证。快速失败迭代器尽最大努力抛出 ConcurrentModificationException。因此，编写依赖于此异常的程序的做法是错误的，正确做法是：迭代器的快速失败行为应该仅用于检测程序错误。<br>参考资料<br><a href="https://www.iteye.com/topic/539465" target="_blank" rel="noopener">深入理解HashMap</a><br><a href="https://www.ibm.com/developerworks/cn/java/j-lo-hash/?ca=drs-tp4608" target="_blank" rel="noopener">通过分析 JDK 源代码研究 Hash 存储机制   </a><br><a href="https://www.iteye.com/topic/368087" target="_blank" rel="noopener">java.util.HashMap源码要点浅析</a></p>

            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2019/08/12/面试之HashMap/">
            <div class="nexmoe-post-cover mdui-ripple"> 
                
                    <img src="https://i.loli.net/2019/01/13/5c3aec85a4343.jpg">
                
                <h1>面试之HashMap</h1>
            </div>
        </a>
        <div class="nexmoe-post-meta">
            <a><i class="nexmoefont icon-calendar-fill"></i>2019年08月12日</a>
            <a><i class="nexmoefont icon-areachart"></i>4k 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 17 分钟</a>
            
            
        </div>
        <article>
            
            <h4 id="HashMap概述："><a href="#HashMap概述：" class="headerlink" title="HashMap概述："></a>HashMap概述：</h4><p> HashMap是基于哈希表的Map接口的非同步实现（Hashtable跟HashMap很像，唯一的区别是Hashtalbe中的方法是线程安全的，也就是同步的）。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p>
<h4 id="HashMap的数据结构："><a href="#HashMap的数据结构：" class="headerlink" title="HashMap的数据结构："></a>HashMap的数据结构：</h4><p> 在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表的数组”的数据结构，每个元素存放链表头结点的数组，即数组和链表的结合体。</p>
<p> HashMap底层就是一个数组，数组中的每一项又是一个链表。当新建一个HashMap的时候，就会初始化一个数组。源码如下：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">transient Entry[] table;</span><br><span class="line"> </span><br><span class="line">static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    final K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line">    final int hash;</span><br><span class="line">    ……</span><br></pre></td></tr></table></figure></p>
<p> 可以看出，Entry就是数组中的元素，每个Map.Entry就是一个key-value对，它持有一个指向下一个元素的引用，这就构成了链表。</p>
<h4 id="HashMap的存取实现："><a href="#HashMap的存取实现：" class="headerlink" title="HashMap的存取实现："></a>HashMap的存取实现：</h4><ul>
<li>存储：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> public V put(K key, V value) &#123;</span><br><span class="line">    // HashMap允许存放null键和null值。</span><br><span class="line">    // 当key为null时，调用putForNullKey方法，将value放置在数组第一个位置。</span><br><span class="line">    if (key == null)</span><br><span class="line">        return putForNullKey(value);</span><br><span class="line">    // 根据key的hashCode重新计算hash值。</span><br><span class="line">    int hash = hash(key.hashCode());</span><br><span class="line">    // 搜索指定hash值所对应table中的索引。</span><br><span class="line">    int i = indexFor(hash, table.length);</span><br><span class="line">    // 如果 i 索引处的 Entry 不为 null，通过循环不断遍历 e 元素的下一个元素。</span><br><span class="line">    for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(this);</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果i索引处的Entry为null，表明此处还没有Entry。</span><br><span class="line">    // modCount记录HashMap中修改结构的次数</span><br><span class="line">    modCount++;</span><br><span class="line">    // 将key、value添加到i索引处。</span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>从上面的源代码中可以看出：当我们往HashMap中put元素的时候，先根据key的hashCode重新计算hash值，根据hash值得到这个元素在数组中的位置（即下标），如果数组该位置上已经存放有其他元素了，那么在这个位置上的元素将以链表的形式存放，新加入的放在链头，最先加入的放在链尾。如果数组该位置上没有元素，就直接将该元素放到此数组中的该位置上。</p>
<p>addEntry(hash, key, value, i)方法根据计算出的hash值，将key-value对放在数组table的 i 索引处。addEntry 是HashMap 提供的一个包访问权限的方法（就是没有public，protected，private这三个访问权限修饰词修饰，为默认的访问权限，用default表示，但在代码中没有这个default），代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void addEntry(int hash, K key, V value, int bucketIndex) &#123;</span><br><span class="line">    // 获取指定 bucketIndex 索引处的 Entry </span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    // 将新创建的 Entry 放入 bucketIndex 索引处，并让新的 Entry 指向原来的 Entry</span><br><span class="line">    table[bucketIndex] = new Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">    // 如果 Map 中的 key-value 对的数量超过了极限</span><br><span class="line">    if (size++ &gt;= threshold)</span><br><span class="line">    // 把 table 对象的长度扩充到原来的2倍。</span><br><span class="line">        resize(2 * table.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当系统决定存储HashMap中的key-value对时，完全没有考虑Entry中的value，仅仅只是根据key来计算并决定每个Entry的存储位置。我们完全可以把 Map 集合中的 value 当成 key 的附属，当系统决定了 key 的存储位置之后，value 随之保存在那里即可。<br>hash(int h)方法根据key的hashCode重新计算一次散列。此算法加入了高位计算，防止低位不变，高位变化时，造成的hash冲突。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">static int hash(int h) &#123;</span><br><span class="line">    h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);</span><br><span class="line">    return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到在HashMap中要找到某个元素，需要根据key的hash值来求得对应数组中的位置。如何计算这个位置就是hash算法。前面说过HashMap的数据结构是数组和链表的结合，所以我们当然希望这个HashMap里面的 元素位置尽量的分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，而不用再去遍历链表，这样就大大优化了查询的效率。</p>
<p>　　对于任意给定的对象，只要它的 hashCode() 返回值相同，那么程序调用 hash(int h) 方法所计算得到的 hash 码值总是相同的。我们首先想到的就是把hash值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，“模”运算的消耗还是比较大的，在HashMap中是这样做的：调用 indexFor(int h, int length) 方法来计算该对象应该保存在 table 数组的哪个索引处。indexFor(int h, int length) 方法的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">static int indexFor(int h, int length) &#123;</span><br><span class="line">    return h &amp; (length-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法非常巧妙，它通过 h &amp; (table.length -1) 来得到该对象的保存位，而HashMap底层数组的长度总是 2 的n 次方，这是HashMap在速度上的优化。在 HashMap 构造器中有如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int capacity = 1;</span><br><span class="line">    while (capacity &lt; initialCapacity)</span><br><span class="line">        capacity &lt;&lt;= 1;</span><br></pre></td></tr></table></figure>

<p>这段代码保证初始化时HashMap的容量总是2的n次方，即底层数组的长度总是为2的n次方。<br>当length总是 2 的n次方时，h&amp; (length-1)运算等价于对length取模，也就是h%length，但是&amp;比%具有更高的效率。<br>这看上去很简单，其实比较有玄机的，我们举个例子来说明：</p>
<p>　　假设数组长度分别为15和16，优化后的hash码分别为8和9，那么&amp;运算后的结果如下：</p>
<pre><code> h &amp; (table.length-1)                     hash                             table.length-1

 8 &amp; (15-1)：                                 0100                   &amp;              1110                   =                0100

 9 &amp; (15-1)：                                 0101                   &amp;              1110                   =                0100

-----------------------------------------------------------------------------------------------------------------------

 8 &amp; (16-1)：                                 0100                   &amp;              1111                   =                0100

 9 &amp; (16-1)：                                 0101                   &amp;              1111                   =                0101

-----------------------------------------------------------------------------------------------------------------------</code></pre><p>　　从上面的例子中可以看出：当8、9两个数和(15-1)2=(1110)进行“与运算&amp;”的时候，产生了相同的结果，都为0100，也就是说它们会定位到数组中的同一个位置上去，这就产生了碰撞，8和9会被放到数组中的同一个位置上形成链表，那么查询的时候就需要遍历这个链 表，得到8或者9，这样就降低了查询的效率。同时，我们也可以发现，当数组长度为15的时候，hash值会与(15-1)2=(1110)进行“与运算&amp;”，那么最后一位永远是0，而0001，0011，0101，1001，1011，0111，1101这几个位置永远都不能存放元素了，空间浪费相当大，更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率，减慢了查询的效率！</p>
<p>　　而当数组长度为16时，即为2的n次方时，2n-1得到的二进制数的每个位上的值都为1（比如(24-1)2=1111），这使得在低位上&amp;时，得到的和原hash的低位相同，加之hash(int h)方法对key的hashCode的进一步优化，加入了高位计算，就使得只有相同的hash值的两个值才会被放到数组中的同一个位置上形成链表。</p>
<p>　　所以说，当数组长度为2的n次幂的时候，不同的key算得得index相同的几率较小，那么数据在数组上分布就比较均匀，也就是说碰撞的几率小，相对的，查询的时候就不用遍历某个位置上的链表，这样查询效率也就较高了。</p>
<p>　　根据上面 put 方法的源代码可以看出，当程序试图将一个key-value对放入HashMap中时，程序首先根据该 key的 hashCode() 返回值决定该 Entry 的存储位置：如果两个 Entry 的 key 的 hashCode() 返回值相同，那它们的存储位置相同。如果这两个 Entry 的 key 通过 equals 比较返回 true，新添加 Entry 的 value 将覆盖集合中原有Entry 的 value，但key不会覆盖。如果这两个 Entry 的 key 通过 equals 比较返回 false，新添加的 Entry 将与集合中原有 Entry 形成 Entry 链，而且新添加的 Entry 位于 Entry 链的头部——具体说明继续看 addEntry() 方法的说明。</p>
<ul>
<li>读取：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">    if (key == null)</span><br><span class="line">        return getForNullKey();</span><br><span class="line">    int hash = hash(key.hashCode());</span><br><span class="line">    for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">        e != null;</span><br><span class="line">        e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))</span><br><span class="line">            return e.value;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>有了上面存储时的hash算法作为基础，理解起来这段代码就很容易了。从上面的源代码中可以看出：从HashMap中get元素时，首先计算key的hashCode，找到数组中对应位置的某一元素，然后通过key的equals方法在对应位置的链表中找到需要的元素。</p>
<ul>
<li><p>归纳起来简单地说，HashMap 在底层将 key-value 当成一个整体进行处理，这个整体就是一个 Entry 对象。HashMap 底层采用一个 Entry[] 数组来保存所有的 key-value 对，当需要存储一个 Entry 对象时，会根据hash算法来决定其在数组中的存储位置，在根据equals方法决定其在该数组位置上的链表中的存储位置；当需要取出一个Entry时，也会根据hash算法找到其在数组中的存储位置，再根据equals方法从该位置上的链表中取出该Entry。</p>
</li>
<li><p>HashMap的resize（rehash）<br>　　当HashMap中的元素越来越多的时候，hash冲突的几率也就越来越高，因为数组的长度是固定的。所以为了提高查询的效率，就要对HashMap的数组进行扩容，数组扩容这个操作也会出现在ArrayList中，这是一个常用的操作，而在HashMap数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize。<br>　　那么HashMap什么时候进行扩容呢？当HashMap中的元素个数超过数组大小<em>loadFactor时，就会进行数组扩容，loadFactor的默认值为0.75，这是一个折中的取值。也就是说，默认情况下，数组大小为16，那么当HashMap中元素个数超过16</em>0.75=12（这个值就是代码中的threshold值，也叫做临界值）的时候，就把数组的大小扩展为 2*16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知HashMap中元素的个数，那么预设元素的个数能够有效的提高HashMap的性能。<br>HashMap扩容的代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//HashMap数组扩容</span><br><span class="line">          void resize(int newCapacity) &#123;</span><br><span class="line">                Entry[] oldTable = table;</span><br><span class="line">                int oldCapacity = oldTable.length;</span><br><span class="line">                //如果当前的数组长度已经达到最大值，则不在进行调整</span><br><span class="line">                if (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                    threshold = Integer.MAX_VALUE;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                //根据传入参数的长度定义新的数组</span><br><span class="line">                Entry[] newTable = new Entry[newCapacity];</span><br><span class="line">                //按照新的规则，将旧数组中的元素转移到新数组中</span><br><span class="line">                transfer(newTable);</span><br><span class="line">                table = newTable;</span><br><span class="line">                //更新临界值</span><br><span class="line">                threshold = (int)(newCapacity * loadFactor);</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">          //旧数组中元素往新数组中迁移</span><br><span class="line">            void transfer(Entry[] newTable) &#123;</span><br><span class="line">                //旧数组</span><br><span class="line">                Entry[] src = table;</span><br><span class="line">                //新数组长度</span><br><span class="line">                int newCapacity = newTable.length;</span><br><span class="line">                //遍历旧数组</span><br><span class="line">                for (int j = 0; j &lt; src.length; j++) &#123;</span><br><span class="line">                    Entry&lt;K,V&gt; e = src[j];</span><br><span class="line">                    if (e != null) &#123;</span><br><span class="line">                        src[j] = null;</span><br><span class="line">                        do &#123;</span><br><span class="line">                            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                            int i = indexFor(e.hash, newCapacity);</span><br><span class="line">                            e.next = newTable[i];</span><br><span class="line">                            newTable[i] = e;</span><br><span class="line">                            e = next;</span><br><span class="line">                        &#125; while (e != null);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>HashMap的性能参数：<br>HashMap 包含如下几个构造器：</p>
</li>
</ul>
<p>1.HashMap()：构建一个初始容量为 16，负载因子为 0.75 的 HashMap。<br>2.HashMap(int initialCapacity)：构建一个初始容量为 initialCapacity，负载因子为 0.75 的 HashMap。<br>3.HashMap(int initialCapacity, float loadFactor)：以指定初始容量、指定的负载因子创建一个 HashMap。<br>4.HashMap的基础构造器HashMap(int initialCapacity, float loadFactor)带有两个参数，它们是初始容量initialCapacity和加载因子loadFactor。<br>5.initialCapacity：HashMap的最大容量，即为底层数组的长度。<br>6.loadFactor：负载因子loadFactor定义为：散列表的实际元素数目(n)/ 散列表的容量(m)。<br>　　负载因子衡量的是一个散列表的空间的使用程度，负载因子越大表示散列表的装填程度越高，反之愈小。对于使用链表法的散列表来说，查找一个元素的平均时间是O(1+a)，因此如果负载因子越大，对空间的利用更充分，然而后果是查找效率的降低；如果负载因子太小，那么散列表的数据将过于稀疏，对空间造成严重浪费。<br>　　HashMap的实现中，通过threshold字段来判断HashMap的最大容量：<br><code>threshold = (int)(capacity * loadFactor);</code><br>结合负载因子的定义公式可知，threshold就是在此loadFactor和capacity对应下允许的最大元素数目，超过这个数目就重新resize，以降低实际的负载因子（也就是说虽然数组长度是capacity，但其扩容的临界值确是threshold）。默认的的负载因子0.75是对空间和时间效率的一个平衡选择。当容量超出此最大容量时， resize后的HashMap容量是容量的两倍：<br><code>if (size++ &gt;= threshold)   
    resize(2 * table.length);</code></p>
<ul>
<li>Fail-Fast机制：<br>　　我们知道java.util.HashMap不是线程安全的，因此如果在使用迭代器的过程中有其他线程修改了map，那么将抛出ConcurrentModificationException，这就是所谓fail-fast策略。（这个在core java这本书中也有提到。）</li>
</ul>
<p>　　这一策略在源码中的实现是通过modCount域，modCount顾名思义就是修改次数，对HashMap内容的修改都将增加这个值，那么在迭代器初始化过程中会将这个值赋给迭代器的expectedModCount。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HashIterator() &#123;</span><br><span class="line">    expectedModCount = modCount;</span><br><span class="line">    if (size &gt; 0) &#123; // advance to first entry</span><br><span class="line">    Entry[] t = table;</span><br><span class="line">    while (index &lt; t.length &amp;&amp; (next = t[index++]) == null)</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在迭代过程中，判断modCount跟expectedModCount是否相等，如果不相等就表示已经有其他线程修改了Map：</p>
<p>　　注意到modCount声明为volatile，保证线程之间修改的可见性。（volatile之所以线程安全是因为被volatile修饰的变量不保存缓存，直接在内存中修改，因此能够保证线程之间修改的可见性）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">final Entry&lt;K,V&gt; nextEntry() &#123;   </span><br><span class="line">    if (modCount != expectedModCount)   </span><br><span class="line">        throw new ConcurrentModificationException();</span><br></pre></td></tr></table></figure>

<p>在HashMap的API中指出：</p>
<p>　　由所有HashMap类的“collection 视图方法”所返回的迭代器都是快速失败的：在迭代器创建之后，如果从结构上对映射进行修改，除非通过迭代器本身的 remove 方法，其他任何时间任何方式的修改，迭代器都将抛出ConcurrentModificationException。因此，面对并发的修改，迭代器很快就会完全失败，而不保证在将来不确定的时间发生任意不确定行为的风险。</p>
<p>　　注意，迭代器的快速失败行为不能得到保证，一般来说，存在非同步的并发修改时，不可能作出任何坚决的保证。快速失败迭代器尽最大努力抛出 ConcurrentModificationException。因此，编写依赖于此异常的程序的做法是错误的，正确做法是：迭代器的快速失败行为应该仅用于检测程序错误。<br>参考资料<br><a href="https://www.iteye.com/topic/539465" target="_blank" rel="noopener">深入理解HashMap</a><br><a href="https://www.ibm.com/developerworks/cn/java/j-lo-hash/?ca=drs-tp4608" target="_blank" rel="noopener">通过分析 JDK 源代码研究 Hash 存储机制   </a><br><a href="https://www.iteye.com/topic/368087" target="_blank" rel="noopener">java.util.HashMap源码要点浅析</a></p>

            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2019/08/10/面试随笔/">
            <div class="nexmoe-post-cover mdui-ripple"> 
                
                    <img src="https://i.loli.net/2019/01/13/5c3aec85a4343.jpg">
                
                <h1>面试随笔</h1>
            </div>
        </a>
        <div class="nexmoe-post-meta">
            <a><i class="nexmoefont icon-calendar-fill"></i>2019年08月10日</a>
            <a><i class="nexmoefont icon-areachart"></i>1.4k 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 6 分钟</a>
            
            
        </div>
        <article>
            
            <h5 id="最近来北京一直在面试，很苦逼的那种，这篇文章主要记录面试中面试官提出的问题，整理出来，熟记于心"><a href="#最近来北京一直在面试，很苦逼的那种，这篇文章主要记录面试中面试官提出的问题，整理出来，熟记于心" class="headerlink" title="最近来北京一直在面试，很苦逼的那种，这篇文章主要记录面试中面试官提出的问题，整理出来，熟记于心"></a>最近来北京一直在面试，很苦逼的那种，这篇文章主要记录面试中面试官提出的问题，整理出来，熟记于心</h5><ul>
<li><p>shiro安全框架</p>
<h5 id="1、怎么利用shiso实现的单点登录？"><a href="#1、怎么利用shiso实现的单点登录？" class="headerlink" title="1、怎么利用shiso实现的单点登录？"></a>1、怎么利用shiso实现的单点登录？</h5><h6 id="shiro加入身份验证"><a href="#shiro加入身份验证" class="headerlink" title="shiro加入身份验证"></a>shiro加入身份验证</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Subject subject = SecurityUtils.getSubject(); </span><br><span class="line">UsernamePasswordToken token = new UsernamePasswordToken(USERNAME, PASSWORD); </span><br><span class="line"> try &#123; </span><br><span class="line">	subject.login(token); </span><br><span class="line">&#125; catch (AuthenticationException e) &#123; </span><br><span class="line">	errInfo = &quot;身份验证失败！&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getSubject 静态方法 (这个是 Shiro 中最核心的方法了，用来获取 Subject)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static Subject getSubject() &#123;</span><br><span class="line">    Subject subject = ThreadContext.getSubject();</span><br><span class="line">    if (subject == null) &#123;</span><br><span class="line">        subject = (new Subject.Builder()).buildSubject();</span><br><span class="line">        ThreadContext.bind(subject);</span><br><span class="line">    &#125;</span><br><span class="line">    return subject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>上述方法中，第二行（Subject subject = ThreadContext.getSubject();）获取到的Subject其实是第五行（ThreadContext.bind(subject);）绑定的。<br> 如果没有之前的绑定则得到null，然后就会走第四行（subject = (new Subject.Builder()).buildSubject();）获取。<br> UsernamePasswordToken //是用来存储用户和密码的<br>subject.login(token);//此方法实现shiro安全登录操作</p>
<h4 id="2、shiro框架是怎么进行权限控制的？"><a href="#2、shiro框架是怎么进行权限控制的？" class="headerlink" title="2、shiro框架是怎么进行权限控制的？"></a>2、shiro框架是怎么进行权限控制的？</h4><h5 id="Shiro-的四种权限控制方式"><a href="#Shiro-的四种权限控制方式" class="headerlink" title="Shiro 的四种权限控制方式"></a>Shiro 的四种权限控制方式</h5><h6 id="URL拦截权限控制：基于filter过滤器实现"><a href="#URL拦截权限控制：基于filter过滤器实现" class="headerlink" title="URL拦截权限控制：基于filter过滤器实现"></a>URL拦截权限控制：基于filter过滤器实现</h6><p>我们在spring配置文件中配置shiroFilter时配置<br> 指定URL级别拦截策略<br>    <code>&lt;property name=&quot;filterChainDefinitions&quot;&gt;</code><br>    <code>&lt;value&gt;</code><br>   <code>/css/ = anon</code><br>   <code>/js/ = anon</code><br>  <code>/images/ = anon</code><br>    <code>/validatecode.jsp = anon</code><br>    <code>/login.jsp = anon</code><br>   <code>/userActionlogin.action = anon</code><br>    <code>/pagebasestaff.action = perms[&quot;staff-list&quot;]</code><br>    <code>/ = authc</code><br>  <code>&lt;/value&gt;</code><br>   <code>&lt;/property&gt;</code></p>
<h6 id="方法注解权限控制：基于代理技术实现"><a href="#方法注解权限控制：基于代理技术实现" class="headerlink" title="方法注解权限控制：基于代理技术实现"></a>方法注解权限控制：基于代理技术实现</h6><p>我们在代码方法上用注解声明调用该方法需要什么权限。<br>首先要在spring配置文件中进行声明开启shiro注解：<br>开启shiro框架注解支持<br>    <code>&lt;bean id=&quot;defaultAdvisorAutoProxyCreator&quot;</code><br>    <code>class=&quot;org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator&quot;&gt;</code><br>    <code>&lt;!-- 必须使用cglib方式为Action对象创建代理对象 --&gt;</code><br>    <code>&lt;property name=&quot;proxyTargetClass&quot; value=&quot;true&quot;/&gt;</code><br>    <code>&lt;/bean&gt;</code><br>    <code>&lt;!-- 配置shiro框架提供的切面类，用于创建代理对象 --&gt;</code><br><code>&lt;bean class=&quot;org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor&quot;/&gt;</code><br>然后在方法上声明：<br><code>@RequiresPermissions(&quot;staff-delete&quot;)</code><br>//执行这个方法，需要当前用户具有staff-delete这个权限<br><code>public String deleteBatch(){
staffService.deleteBatch(ids);
return LIST;
}</code></p>
<h6 id="页面标签权限控制：页面表签技术实现"><a href="#页面标签权限控制：页面表签技术实现" class="headerlink" title="页面标签权限控制：页面表签技术实现"></a>页面标签权限控制：页面表签技术实现</h6><p>首先要在jsp页面进入表签：<br><code>&lt;%@ taglib uri=&quot;http://shiro.apache.org/tags&quot; prefix=&quot;shiro&quot; %&gt;</code><br>然后包裹权限控制的内容<br><code>&lt;shiro:hasPermission name=&quot;Permission&quot;&gt;</code><br>xxxxxxxxxxxxxxxx<br><code>&lt;/shiro:hasPermission&gt;</code></p>
<h6 id="代码级别权限控制："><a href="#代码级别权限控制：" class="headerlink" title="代码级别权限控制："></a>代码级别权限控制：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public String edit()&#123;</span><br><span class="line">Subject subject = SecurityUtils.getSubject();</span><br><span class="line">subject.checkPermission(&quot;staff-edit&quot;);</span><br><span class="line">Staff staff = staffService.findById(model.getId());</span><br><span class="line">staff.setName(model.getName());</span><br><span class="line">staff.setTelephone(model.getTelephone());</span><br><span class="line">staff.setHaspda(model.getHaspda());</span><br><span class="line">staff.setStandard(model.getStandard());</span><br><span class="line">staff.setStation(model.getStation());</span><br><span class="line">staffService.update(staff);</span><br><span class="line">return LIST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><p>使用shiro进行权限控制时 这四种方法并不是进行单一的使用，是相互结合的使用从而完整的进行权限控制。<br>详见网址<a href="https://www.cnblogs.com/cocosili/p/7103025.html" target="_blank" rel="noopener">点击跳转</a></p>
<ul>
<li>Mybatis 中一级缓存与二级缓存？<br>1、一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Session flush 或<br>close 之后，该 Session 中的所有 Cache 就将清空。<br>2、二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于其存储作用域为<br>Mapper(Namespace)，并且可自定义存储源，如 Ehcache。作用域为 namespance 是指对该 namespance 对应的<br>配置文件中所有的 select 操作结果都缓存，这样不同线程之间就可以共用二级缓存。启动二级缓存：在 mapper 配置<br>文件中：<code>&lt;cache /&gt;</code>。<br>二级缓存可以设置返回的缓存对象策略：<code>&lt;cache readOnly=&quot;true&quot;&gt;</code>。当 readOnly=”true”时，表示二级缓存返<br>回给所有调用者同一个缓存对象实例，调用者可以 update 获取的缓存实例，但是这样可能会造成其他调用者出现数<br>据不一致的情况（因为所有调用者调用的是同一个实例）。当 readOnly=”false”时，返回给调用者的是二级缓存总缓<br>存对象的拷贝，即不同调用者获取的是缓存对象不同的实例，这样调用者对各自的缓存对象的修改不会影响到其他的<br>调用者，即是安全的，所以默认是 readOnly=”false”;<br>3、对于缓存数据更新机制，当某一个作用域(一级缓存 Session/二级缓存 Namespaces)的进行了 C/U/D 操作后，<br>默认该作用域下所有 select 中的缓存将被 clear。</li>
<li>什么是Spring的依赖注入？<br>平常的 java 开发中，程序员在某个类中需要依赖其它类的方法，则通常是 new 一个依赖类再调用类实例的方法，<br>这种开发存在的问题是 new 的类实例不好统一管理，spring 提出了依赖注入的思想，即依赖类不由程序员实例化，而<br>是通过 spring 容器帮我们 new 指定实例并且将实例注入到需要该对象的类中。依赖注入的另一种说法是“控制反<br>转”，通俗的理解是：平常我们 new 一个实例，这个实例的控制权是我们程序员，而控制反转是指 new 实例工作不<br>由我们程序员来做而是交给 spring 容器来做。</li>
<li>有哪些不同类型的 IOC（依赖注入）方式？<br>1、Set注入<br>2、构造器注入<br>3、静态方法注入<br>4、实例工厂的方法注入<br><a href="https://www.cnblogs.com/java-class/p/4727775.html" target="_blank" rel="noopener">详见</a></li>
<li>java多线程 操作题：</li>
</ul>
<p>。。。。。。。。未完待续</p>

            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2019/08/06/article-title/">
            <div class="nexmoe-post-cover mdui-ripple"> 
                
                    <img src="https://i.loli.net/2019/01/13/5c3aec85a4343.jpg">
                
                <h1>article title</h1>
            </div>
        </a>
        <div class="nexmoe-post-meta">
            <a><i class="nexmoefont icon-calendar-fill"></i>2019年08月06日</a>
            <a><i class="nexmoefont icon-areachart"></i>9 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 1 分钟</a>
            
            
        </div>
        <article>
            
            <h1 id="第一次写博客"><a href="#第一次写博客" class="headerlink" title="第一次写博客"></a>第一次写博客</h1><h2 id="vscode编写md"><a href="#vscode编写md" class="headerlink" title="vscode编写md"></a>vscode编写md</h2>
            
        </article>
    </div>
    
</section>

    </div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/mdui@0.4.3/dist/js/mdui.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script>
 
    <script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>


 
    <script src="https://cdn.jsdelivr.net/npm/smoothscroll-for-websites@1.4.9/SmoothScroll.min.js"></script>


<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.15.8/build/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<script src="/js/app.js?v=1608868108092"></script>
<script src="https://cdn.jsdelivr.net/npm/lazysizes@5.1.0/lazysizes.min.js"></script>

  





</body>

</html>
<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[面试随笔]]></title>
    <url>%2F2019%2F08%2F10%2F%E9%9D%A2%E8%AF%95%E9%9A%8F%E7%AC%94%2F</url>
    <content type="text"><![CDATA[最近来北京一直在面试，很苦逼的那种，这篇文章主要记录面试中面试官提出的问题，整理出来，熟记于心 shiro安全框架 1、怎么利用shiso实现的单点登录？shiro加入身份验证1234567Subject subject = SecurityUtils.getSubject(); UsernamePasswordToken token = new UsernamePasswordToken(USERNAME, PASSWORD); try &#123; subject.login(token); &#125; catch (AuthenticationException e) &#123; errInfo = &quot;身份验证失败！&quot;;&#125; getSubject 静态方法 (这个是 Shiro 中最核心的方法了，用来获取 Subject) 12345678public static Subject getSubject() &#123; Subject subject = ThreadContext.getSubject(); if (subject == null) &#123; subject = (new Subject.Builder()).buildSubject(); ThreadContext.bind(subject); &#125; return subject;&#125; 上述方法中，第二行（Subject subject = ThreadContext.getSubject();）获取到的Subject其实是第五行（ThreadContext.bind(subject);）绑定的。 如果没有之前的绑定则得到null，然后就会走第四行（subject = (new Subject.Builder()).buildSubject();）获取。 UsernamePasswordToken //是用来存储用户和密码的subject.login(token);//此方法实现shiro安全登录操作 2、shiro框架是怎么进行权限控制的？Shiro 的四种权限控制方式URL拦截权限控制：基于filter过滤器实现我们在spring配置文件中配置shiroFilter时配置 指定URL级别拦截策略 &lt;property name=&quot;filterChainDefinitions&quot;&gt; &lt;value&gt; /css/ = anon /js/ = anon /images/ = anon /validatecode.jsp = anon /login.jsp = anon /userActionlogin.action = anon /pagebasestaff.action = perms[&quot;staff-list&quot;] / = authc &lt;/value&gt; &lt;/property&gt; 方法注解权限控制：基于代理技术实现我们在代码方法上用注解声明调用该方法需要什么权限。首先要在spring配置文件中进行声明开启shiro注解：开启shiro框架注解支持 &lt;bean id=&quot;defaultAdvisorAutoProxyCreator&quot; class=&quot;org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator&quot;&gt; &lt;!-- 必须使用cglib方式为Action对象创建代理对象 --&gt; &lt;property name=&quot;proxyTargetClass&quot; value=&quot;true&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置shiro框架提供的切面类，用于创建代理对象 --&gt;&lt;bean class=&quot;org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor&quot;/&gt;然后在方法上声明：@RequiresPermissions(&quot;staff-delete&quot;)//执行这个方法，需要当前用户具有staff-delete这个权限public String deleteBatch(){ staffService.deleteBatch(ids); return LIST; } 页面标签权限控制：页面表签技术实现首先要在jsp页面进入表签：&lt;%@ taglib uri=&quot;http://shiro.apache.org/tags&quot; prefix=&quot;shiro&quot; %&gt;然后包裹权限控制的内容&lt;shiro:hasPermission name=&quot;Permission&quot;&gt;xxxxxxxxxxxxxxxx&lt;/shiro:hasPermission&gt; 代码级别权限控制：123456789101112public String edit()&#123;Subject subject = SecurityUtils.getSubject();subject.checkPermission(&quot;staff-edit&quot;);Staff staff = staffService.findById(model.getId());staff.setName(model.getName());staff.setTelephone(model.getTelephone());staff.setHaspda(model.getHaspda());staff.setStandard(model.getStandard());staff.setStation(model.getStation());staffService.update(staff);return LIST;&#125; 总结：使用shiro进行权限控制时 这四种方法并不是进行单一的使用，是相互结合的使用从而完整的进行权限控制。详见网址点击跳转 Mybatis 中一级缓存与二级缓存？1、一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Session flush 或close 之后，该 Session 中的所有 Cache 就将清空。2、二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于其存储作用域为Mapper(Namespace)，并且可自定义存储源，如 Ehcache。作用域为 namespance 是指对该 namespance 对应的配置文件中所有的 select 操作结果都缓存，这样不同线程之间就可以共用二级缓存。启动二级缓存：在 mapper 配置文件中：&lt;cache /&gt;。二级缓存可以设置返回的缓存对象策略：&lt;cache readOnly=&quot;true&quot;&gt;。当 readOnly=”true”时，表示二级缓存返回给所有调用者同一个缓存对象实例，调用者可以 update 获取的缓存实例，但是这样可能会造成其他调用者出现数据不一致的情况（因为所有调用者调用的是同一个实例）。当 readOnly=”false”时，返回给调用者的是二级缓存总缓存对象的拷贝，即不同调用者获取的是缓存对象不同的实例，这样调用者对各自的缓存对象的修改不会影响到其他的调用者，即是安全的，所以默认是 readOnly=”false”;3、对于缓存数据更新机制，当某一个作用域(一级缓存 Session/二级缓存 Namespaces)的进行了 C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。 什么是Spring的依赖注入？平常的 java 开发中，程序员在某个类中需要依赖其它类的方法，则通常是 new 一个依赖类再调用类实例的方法，这种开发存在的问题是 new 的类实例不好统一管理，spring 提出了依赖注入的思想，即依赖类不由程序员实例化，而是通过 spring 容器帮我们 new 指定实例并且将实例注入到需要该对象的类中。依赖注入的另一种说法是“控制反转”，通俗的理解是：平常我们 new 一个实例，这个实例的控制权是我们程序员，而控制反转是指 new 实例工作不由我们程序员来做而是交给 spring 容器来做。 有哪些不同类型的 IOC（依赖注入）方式？1、Set注入2、构造器注入3、静态方法注入4、实例工厂的方法注入详见 java多线程 操作题： 。。。。。。。。未完待续]]></content>
  </entry>
  <entry>
    <title><![CDATA[article title]]></title>
    <url>%2F2019%2F08%2F06%2Farticle-title%2F</url>
    <content type="text"><![CDATA[第一次写博客vscode编写md]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F08%2F06%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>

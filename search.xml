<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[面试之HashMap]]></title>
    <url>%2F2019%2F08%2F12%2F%E9%9D%A2%E8%AF%95%E4%B9%8BHashMap%2F</url>
    <content type="text"><![CDATA[HashMap概述： HashMap是基于哈希表的Map接口的非同步实现（Hashtable跟HashMap很像，唯一的区别是Hashtalbe中的方法是线程安全的，也就是同步的）。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。 HashMap的数据结构： 在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表的数组”的数据结构，每个元素存放链表头结点的数组，即数组和链表的结合体。 HashMap底层就是一个数组，数组中的每一项又是一个链表。当新建一个HashMap的时候，就会初始化一个数组。源码如下： 12345678transient Entry[] table; static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final K key; V value; Entry&lt;K,V&gt; next; final int hash; …… 可以看出，Entry就是数组中的元素，每个Map.Entry就是一个key-value对，它持有一个指向下一个元素的引用，这就构成了链表。 HashMap的存取实现： 存储：123456789101112131415161718192021222324252627 public V put(K key, V value) &#123; // HashMap允许存放null键和null值。 // 当key为null时，调用putForNullKey方法，将value放置在数组第一个位置。 if (key == null) return putForNullKey(value); // 根据key的hashCode重新计算hash值。 int hash = hash(key.hashCode()); // 搜索指定hash值所对应table中的索引。 int i = indexFor(hash, table.length); // 如果 i 索引处的 Entry 不为 null，通过循环不断遍历 e 元素的下一个元素。 for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; // 如果i索引处的Entry为null，表明此处还没有Entry。 // modCount记录HashMap中修改结构的次数 modCount++; // 将key、value添加到i索引处。 addEntry(hash, key, value, i); return null;&#125; 从上面的源代码中可以看出：当我们往HashMap中put元素的时候，先根据key的hashCode重新计算hash值，根据hash值得到这个元素在数组中的位置（即下标），如果数组该位置上已经存放有其他元素了，那么在这个位置上的元素将以链表的形式存放，新加入的放在链头，最先加入的放在链尾。如果数组该位置上没有元素，就直接将该元素放到此数组中的该位置上。 addEntry(hash, key, value, i)方法根据计算出的hash值，将key-value对放在数组table的 i 索引处。addEntry 是HashMap 提供的一个包访问权限的方法（就是没有public，protected，private这三个访问权限修饰词修饰，为默认的访问权限，用default表示，但在代码中没有这个default），代码如下： 1234567891011void addEntry(int hash, K key, V value, int bucketIndex) &#123; // 获取指定 bucketIndex 索引处的 Entry Entry&lt;K,V&gt; e = table[bucketIndex]; // 将新创建的 Entry 放入 bucketIndex 索引处，并让新的 Entry 指向原来的 Entry table[bucketIndex] = new Entry&lt;K,V&gt;(hash, key, value, e); // 如果 Map 中的 key-value 对的数量超过了极限 if (size++ &gt;= threshold) // 把 table 对象的长度扩充到原来的2倍。 resize(2 * table.length);&#125; 当系统决定存储HashMap中的key-value对时，完全没有考虑Entry中的value，仅仅只是根据key来计算并决定每个Entry的存储位置。我们完全可以把 Map 集合中的 value 当成 key 的附属，当系统决定了 key 的存储位置之后，value 随之保存在那里即可。hash(int h)方法根据key的hashCode重新计算一次散列。此算法加入了高位计算，防止低位不变，高位变化时，造成的hash冲突。 12345static int hash(int h) &#123; h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);&#125; 我们可以看到在HashMap中要找到某个元素，需要根据key的hash值来求得对应数组中的位置。如何计算这个位置就是hash算法。前面说过HashMap的数据结构是数组和链表的结合，所以我们当然希望这个HashMap里面的 元素位置尽量的分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，而不用再去遍历链表，这样就大大优化了查询的效率。 对于任意给定的对象，只要它的 hashCode() 返回值相同，那么程序调用 hash(int h) 方法所计算得到的 hash 码值总是相同的。我们首先想到的就是把hash值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，“模”运算的消耗还是比较大的，在HashMap中是这样做的：调用 indexFor(int h, int length) 方法来计算该对象应该保存在 table 数组的哪个索引处。indexFor(int h, int length) 方法的代码如下： 1234static int indexFor(int h, int length) &#123; return h &amp; (length-1);&#125; 这个方法非常巧妙，它通过 h &amp; (table.length -1) 来得到该对象的保存位，而HashMap底层数组的长度总是 2 的n 次方，这是HashMap在速度上的优化。在 HashMap 构造器中有如下代码： 123int capacity = 1; while (capacity &lt; initialCapacity) capacity &lt;&lt;= 1; 这段代码保证初始化时HashMap的容量总是2的n次方，即底层数组的长度总是为2的n次方。当length总是 2 的n次方时，h&amp; (length-1)运算等价于对length取模，也就是h%length，但是&amp;比%具有更高的效率。这看上去很简单，其实比较有玄机的，我们举个例子来说明： 假设数组长度分别为15和16，优化后的hash码分别为8和9，那么&amp;运算后的结果如下： h &amp; (table.length-1) hash table.length-1 8 &amp; (15-1)： 0100 &amp; 1110 = 0100 9 &amp; (15-1)： 0101 &amp; 1110 = 0100 ----------------------------------------------------------------------------------------------------------------------- 8 &amp; (16-1)： 0100 &amp; 1111 = 0100 9 &amp; (16-1)： 0101 &amp; 1111 = 0101 ----------------------------------------------------------------------------------------------------------------------- 从上面的例子中可以看出：当8、9两个数和(15-1)2=(1110)进行“与运算&amp;”的时候，产生了相同的结果，都为0100，也就是说它们会定位到数组中的同一个位置上去，这就产生了碰撞，8和9会被放到数组中的同一个位置上形成链表，那么查询的时候就需要遍历这个链 表，得到8或者9，这样就降低了查询的效率。同时，我们也可以发现，当数组长度为15的时候，hash值会与(15-1)2=(1110)进行“与运算&amp;”，那么最后一位永远是0，而0001，0011，0101，1001，1011，0111，1101这几个位置永远都不能存放元素了，空间浪费相当大，更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率，减慢了查询的效率！ 而当数组长度为16时，即为2的n次方时，2n-1得到的二进制数的每个位上的值都为1（比如(24-1)2=1111），这使得在低位上&amp;时，得到的和原hash的低位相同，加之hash(int h)方法对key的hashCode的进一步优化，加入了高位计算，就使得只有相同的hash值的两个值才会被放到数组中的同一个位置上形成链表。 所以说，当数组长度为2的n次幂的时候，不同的key算得得index相同的几率较小，那么数据在数组上分布就比较均匀，也就是说碰撞的几率小，相对的，查询的时候就不用遍历某个位置上的链表，这样查询效率也就较高了。 根据上面 put 方法的源代码可以看出，当程序试图将一个key-value对放入HashMap中时，程序首先根据该 key的 hashCode() 返回值决定该 Entry 的存储位置：如果两个 Entry 的 key 的 hashCode() 返回值相同，那它们的存储位置相同。如果这两个 Entry 的 key 通过 equals 比较返回 true，新添加 Entry 的 value 将覆盖集合中原有Entry 的 value，但key不会覆盖。如果这两个 Entry 的 key 通过 equals 比较返回 false，新添加的 Entry 将与集合中原有 Entry 形成 Entry 链，而且新添加的 Entry 位于 Entry 链的头部——具体说明继续看 addEntry() 方法的说明。 读取：12345678910111213public V get(Object key) &#123; if (key == null) return getForNullKey(); int hash = hash(key.hashCode()); for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) return e.value; &#125; return null;&#125; 有了上面存储时的hash算法作为基础，理解起来这段代码就很容易了。从上面的源代码中可以看出：从HashMap中get元素时，首先计算key的hashCode，找到数组中对应位置的某一元素，然后通过key的equals方法在对应位置的链表中找到需要的元素。 归纳起来简单地说，HashMap 在底层将 key-value 当成一个整体进行处理，这个整体就是一个 Entry 对象。HashMap 底层采用一个 Entry[] 数组来保存所有的 key-value 对，当需要存储一个 Entry 对象时，会根据hash算法来决定其在数组中的存储位置，在根据equals方法决定其在该数组位置上的链表中的存储位置；当需要取出一个Entry时，也会根据hash算法找到其在数组中的存储位置，再根据equals方法从该位置上的链表中取出该Entry。 HashMap的resize（rehash） 当HashMap中的元素越来越多的时候，hash冲突的几率也就越来越高，因为数组的长度是固定的。所以为了提高查询的效率，就要对HashMap的数组进行扩容，数组扩容这个操作也会出现在ArrayList中，这是一个常用的操作，而在HashMap数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize。 那么HashMap什么时候进行扩容呢？当HashMap中的元素个数超过数组大小loadFactor时，就会进行数组扩容，loadFactor的默认值为0.75，这是一个折中的取值。也就是说，默认情况下，数组大小为16，那么当HashMap中元素个数超过160.75=12（这个值就是代码中的threshold值，也叫做临界值）的时候，就把数组的大小扩展为 2*16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知HashMap中元素的个数，那么预设元素的个数能够有效的提高HashMap的性能。HashMap扩容的代码如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940//HashMap数组扩容 void resize(int newCapacity) &#123; Entry[] oldTable = table; int oldCapacity = oldTable.length; //如果当前的数组长度已经达到最大值，则不在进行调整 if (oldCapacity == MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return; &#125; //根据传入参数的长度定义新的数组 Entry[] newTable = new Entry[newCapacity]; //按照新的规则，将旧数组中的元素转移到新数组中 transfer(newTable); table = newTable; //更新临界值 threshold = (int)(newCapacity * loadFactor); &#125; //旧数组中元素往新数组中迁移 void transfer(Entry[] newTable) &#123; //旧数组 Entry[] src = table; //新数组长度 int newCapacity = newTable.length; //遍历旧数组 for (int j = 0; j &lt; src.length; j++) &#123; Entry&lt;K,V&gt; e = src[j]; if (e != null) &#123; src[j] = null; do &#123; Entry&lt;K,V&gt; next = e.next; int i = indexFor(e.hash, newCapacity); e.next = newTable[i]; newTable[i] = e; e = next; &#125; while (e != null); &#125; &#125; &#125; HashMap的性能参数：HashMap 包含如下几个构造器： 1.HashMap()：构建一个初始容量为 16，负载因子为 0.75 的 HashMap。2.HashMap(int initialCapacity)：构建一个初始容量为 initialCapacity，负载因子为 0.75 的 HashMap。3.HashMap(int initialCapacity, float loadFactor)：以指定初始容量、指定的负载因子创建一个 HashMap。4.HashMap的基础构造器HashMap(int initialCapacity, float loadFactor)带有两个参数，它们是初始容量initialCapacity和加载因子loadFactor。5.initialCapacity：HashMap的最大容量，即为底层数组的长度。6.loadFactor：负载因子loadFactor定义为：散列表的实际元素数目(n)/ 散列表的容量(m)。 负载因子衡量的是一个散列表的空间的使用程度，负载因子越大表示散列表的装填程度越高，反之愈小。对于使用链表法的散列表来说，查找一个元素的平均时间是O(1+a)，因此如果负载因子越大，对空间的利用更充分，然而后果是查找效率的降低；如果负载因子太小，那么散列表的数据将过于稀疏，对空间造成严重浪费。 HashMap的实现中，通过threshold字段来判断HashMap的最大容量：threshold = (int)(capacity * loadFactor);结合负载因子的定义公式可知，threshold就是在此loadFactor和capacity对应下允许的最大元素数目，超过这个数目就重新resize，以降低实际的负载因子（也就是说虽然数组长度是capacity，但其扩容的临界值确是threshold）。默认的的负载因子0.75是对空间和时间效率的一个平衡选择。当容量超出此最大容量时， resize后的HashMap容量是容量的两倍：if (size++ &gt;= threshold) resize(2 * table.length); Fail-Fast机制： 我们知道java.util.HashMap不是线程安全的，因此如果在使用迭代器的过程中有其他线程修改了map，那么将抛出ConcurrentModificationException，这就是所谓fail-fast策略。（这个在core java这本书中也有提到。） 这一策略在源码中的实现是通过modCount域，modCount顾名思义就是修改次数，对HashMap内容的修改都将增加这个值，那么在迭代器初始化过程中会将这个值赋给迭代器的expectedModCount。 12345678HashIterator() &#123; expectedModCount = modCount; if (size &gt; 0) &#123; // advance to first entry Entry[] t = table; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null) ; &#125;&#125; 在迭代过程中，判断modCount跟expectedModCount是否相等，如果不相等就表示已经有其他线程修改了Map： 注意到modCount声明为volatile，保证线程之间修改的可见性。（volatile之所以线程安全是因为被volatile修饰的变量不保存缓存，直接在内存中修改，因此能够保证线程之间修改的可见性）。 123final Entry&lt;K,V&gt; nextEntry() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); 在HashMap的API中指出： 由所有HashMap类的“collection 视图方法”所返回的迭代器都是快速失败的：在迭代器创建之后，如果从结构上对映射进行修改，除非通过迭代器本身的 remove 方法，其他任何时间任何方式的修改，迭代器都将抛出ConcurrentModificationException。因此，面对并发的修改，迭代器很快就会完全失败，而不保证在将来不确定的时间发生任意不确定行为的风险。 注意，迭代器的快速失败行为不能得到保证，一般来说，存在非同步的并发修改时，不可能作出任何坚决的保证。快速失败迭代器尽最大努力抛出 ConcurrentModificationException。因此，编写依赖于此异常的程序的做法是错误的，正确做法是：迭代器的快速失败行为应该仅用于检测程序错误。参考资料深入理解HashMap通过分析 JDK 源代码研究 Hash 存储机制 java.util.HashMap源码要点浅析]]></content>
  </entry>
  <entry>
    <title><![CDATA[面试随笔]]></title>
    <url>%2F2019%2F08%2F10%2F%E9%9D%A2%E8%AF%95%E9%9A%8F%E7%AC%94%2F</url>
    <content type="text"><![CDATA[最近来北京一直在面试，很苦逼的那种，这篇文章主要记录面试中面试官提出的问题，整理出来，熟记于心 shiro安全框架 1、怎么利用shiso实现的单点登录？shiro加入身份验证1234567Subject subject = SecurityUtils.getSubject(); UsernamePasswordToken token = new UsernamePasswordToken(USERNAME, PASSWORD); try &#123; subject.login(token); &#125; catch (AuthenticationException e) &#123; errInfo = &quot;身份验证失败！&quot;;&#125; getSubject 静态方法 (这个是 Shiro 中最核心的方法了，用来获取 Subject) 12345678public static Subject getSubject() &#123; Subject subject = ThreadContext.getSubject(); if (subject == null) &#123; subject = (new Subject.Builder()).buildSubject(); ThreadContext.bind(subject); &#125; return subject;&#125; 上述方法中，第二行（Subject subject = ThreadContext.getSubject();）获取到的Subject其实是第五行（ThreadContext.bind(subject);）绑定的。 如果没有之前的绑定则得到null，然后就会走第四行（subject = (new Subject.Builder()).buildSubject();）获取。 UsernamePasswordToken //是用来存储用户和密码的subject.login(token);//此方法实现shiro安全登录操作 2、shiro框架是怎么进行权限控制的？Shiro 的四种权限控制方式URL拦截权限控制：基于filter过滤器实现我们在spring配置文件中配置shiroFilter时配置 指定URL级别拦截策略 &lt;property name=&quot;filterChainDefinitions&quot;&gt; &lt;value&gt; /css/ = anon /js/ = anon /images/ = anon /validatecode.jsp = anon /login.jsp = anon /userActionlogin.action = anon /pagebasestaff.action = perms[&quot;staff-list&quot;] / = authc &lt;/value&gt; &lt;/property&gt; 方法注解权限控制：基于代理技术实现我们在代码方法上用注解声明调用该方法需要什么权限。首先要在spring配置文件中进行声明开启shiro注解：开启shiro框架注解支持 &lt;bean id=&quot;defaultAdvisorAutoProxyCreator&quot; class=&quot;org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator&quot;&gt; &lt;!-- 必须使用cglib方式为Action对象创建代理对象 --&gt; &lt;property name=&quot;proxyTargetClass&quot; value=&quot;true&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置shiro框架提供的切面类，用于创建代理对象 --&gt;&lt;bean class=&quot;org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor&quot;/&gt;然后在方法上声明：@RequiresPermissions(&quot;staff-delete&quot;)//执行这个方法，需要当前用户具有staff-delete这个权限public String deleteBatch(){ staffService.deleteBatch(ids); return LIST; } 页面标签权限控制：页面表签技术实现首先要在jsp页面进入表签：&lt;%@ taglib uri=&quot;http://shiro.apache.org/tags&quot; prefix=&quot;shiro&quot; %&gt;然后包裹权限控制的内容&lt;shiro:hasPermission name=&quot;Permission&quot;&gt;xxxxxxxxxxxxxxxx&lt;/shiro:hasPermission&gt; 代码级别权限控制：123456789101112public String edit()&#123;Subject subject = SecurityUtils.getSubject();subject.checkPermission(&quot;staff-edit&quot;);Staff staff = staffService.findById(model.getId());staff.setName(model.getName());staff.setTelephone(model.getTelephone());staff.setHaspda(model.getHaspda());staff.setStandard(model.getStandard());staff.setStation(model.getStation());staffService.update(staff);return LIST;&#125; 总结：使用shiro进行权限控制时 这四种方法并不是进行单一的使用，是相互结合的使用从而完整的进行权限控制。详见网址点击跳转 Mybatis 中一级缓存与二级缓存？1、一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Session flush 或close 之后，该 Session 中的所有 Cache 就将清空。2、二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于其存储作用域为Mapper(Namespace)，并且可自定义存储源，如 Ehcache。作用域为 namespance 是指对该 namespance 对应的配置文件中所有的 select 操作结果都缓存，这样不同线程之间就可以共用二级缓存。启动二级缓存：在 mapper 配置文件中：&lt;cache /&gt;。二级缓存可以设置返回的缓存对象策略：&lt;cache readOnly=&quot;true&quot;&gt;。当 readOnly=”true”时，表示二级缓存返回给所有调用者同一个缓存对象实例，调用者可以 update 获取的缓存实例，但是这样可能会造成其他调用者出现数据不一致的情况（因为所有调用者调用的是同一个实例）。当 readOnly=”false”时，返回给调用者的是二级缓存总缓存对象的拷贝，即不同调用者获取的是缓存对象不同的实例，这样调用者对各自的缓存对象的修改不会影响到其他的调用者，即是安全的，所以默认是 readOnly=”false”;3、对于缓存数据更新机制，当某一个作用域(一级缓存 Session/二级缓存 Namespaces)的进行了 C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。 什么是Spring的依赖注入？平常的 java 开发中，程序员在某个类中需要依赖其它类的方法，则通常是 new 一个依赖类再调用类实例的方法，这种开发存在的问题是 new 的类实例不好统一管理，spring 提出了依赖注入的思想，即依赖类不由程序员实例化，而是通过 spring 容器帮我们 new 指定实例并且将实例注入到需要该对象的类中。依赖注入的另一种说法是“控制反转”，通俗的理解是：平常我们 new 一个实例，这个实例的控制权是我们程序员，而控制反转是指 new 实例工作不由我们程序员来做而是交给 spring 容器来做。 有哪些不同类型的 IOC（依赖注入）方式？1、Set注入2、构造器注入3、静态方法注入4、实例工厂的方法注入详见 java多线程 操作题： 。。。。。。。。未完待续]]></content>
  </entry>
  <entry>
    <title><![CDATA[article title]]></title>
    <url>%2F2019%2F08%2F06%2Farticle-title%2F</url>
    <content type="text"><![CDATA[第一次写博客vscode编写md]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F08%2F06%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
